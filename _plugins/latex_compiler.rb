# _plugins/tex_to_md.rb
require "jekyll"

module TexToMd
  POSTS_DIR = "_posts"                       # change if you want another collection
  # Extract LaTeX \title{…} (or \title[short]{long})
  # Returns nil if nothing found.
  def self.extract_title(tex_path)
    inside_title = false
    buf = +""
  
    File.foreach(tex_path) do |line|
      # ignore full-line comments
      next if line.lstrip.start_with?("%")
  
      # remove inline comments (cheap but works for most cases)
      clean = line.split(/(?<!\\)%/).first
  
      if inside_title
        buf << clean
        if clean.include?("}")
          return buf.sub(/}.*$/, "").strip          # stop at closing brace
        end
      elsif clean =~ /\\title\s*(\[[^\]]*\])?\s*{(.*)/
        inside_title = true
        after_brace  = $2
        if after_brace.include?("}")
          return after_brace.sub(/}.*$/, "").strip.gsub(":", "")  # one-liner title
        else
          buf << after_brace
        end
      end
    end
  
    nil   
  end

  # Remove Jekyll-style date prefix (YYYY-MM-DD-) from filename
  def self.clean_filename_for_title(filename)
    # Remove .tex extension and then remove date prefix if present
    basename = File.basename(filename, ".tex")
    # Remove date prefix pattern (YYYY-MM-DD-) from the beginning
    cleaned = basename.sub(/^\d{4}-\d{2}-\d{2}-/, "")
    # Convert to title case
    cleaned.tr("-", " ").split.map(&:capitalize).join(" ")
  end

  # Common compilation logic
  def self.compile_tex_files(site, force_recompile: true)
    Dir.glob(File.join(site.source, "**", "*.tex")).each do |tex|
      # Re-compile only if the .tex is newer
      md_file = tex.sub(/\.tex$/, ".md")
      unless not force_recompile
        next if File.exist?(md_file) && File.mtime(md_file) >= File.mtime(tex)
      end

      puts "Pandoc ⇒ #{File.basename(md_file)}"

      markdown_filter = File.join(site.source, "_plugins", "austin-latex-filter-markdown.lua")
      html_filter = File.join(site.source, "_plugins", "austin-latex-filter.lua")

      title = TexToMd.extract_title(tex) || TexToMd.clean_filename_for_title(tex)
      date = "#{File.mtime(tex).strftime("%Y-%m-%d")}"

      # Resume clause 
      if tex.downcase.include?("resume")
        html_output_filename = tex.sub(/\.tex$/, ".html") 
        pandoc_html_command_parts = ["pandoc", "--lua-filter", html_filter, tex, "-o", html_output_filename, "-t", "html"]
        
        # Execute pandoc command for HTML generation
        system(*pandoc_html_command_parts) or abort "Pandoc failed to convert resume TeX file '#{tex}' to HTML."
        html_content = File.read(html_output_filename)
        File.delete(html_output_filename) if File.exist?(html_output_filename)

        relative_path = Pathname.new(tex).relative_path_from(Pathname.new(site.source)).to_s
        pdf_path = relative_path.sub(/\.tex$/, ".pdf")

        # Create/overwrite the .md file with Jekyll front matter and embedded HTML
        File.open(md_file, "w") do |f|
          f.write("---\n")
          f.write("layout: page\n") # Resumes often use a 'page' layout
          f.write("title: #{title}\n")
          f.write("last_updated: #{File.mtime(tex).strftime("%Y-%m-%d")}\n")
          f.write("---\n\n")
          f.write("[comment]: THIS FILE IS AUTOMATICALLY GENERATED FROM #{File.basename(tex)}. IT WILL BE REWRITTEN ON CHANGE OF THE .tex FILE!\n\n")
          f.write("<h1><a href=\"/#{pdf_path}\">PDF Version</a></h1>\n")
          f.write(html_content)
        end
        puts "  Created Markdown wrapper: #{md_file} with embedded HTML content."
      else
        system("pandoc", tex, "-o", md_file, "--lua-filter", markdown_filter, "-t", "markdown") or abort "Pandoc failed"

        

        # Ensure the Markdown has (at least) empty front-matter
        first = File.open(md_file, &:readline) rescue ""
        unless first.start_with?("---")
          File.open(md_file, "r+") do |f|
            body = f.read
            f.rewind
            f.write("---\n")
            f.write("layout: post\n") # Resumes often use a 'page' layout
            f.write("title: #{title}\n")
            f.write("last_updated: #{File.mtime(tex).strftime("%Y-%m-%d")}\n")
            f.write("---\n\n")
            f.write("[comment]: THIS FILE IS AUTOMATICALLY GENERATED FROM #{File.basename(tex)}. IT WILL BE REWRITTEN ON CHANGE OF THE .tex FILE!\n\n")
            f.write(body)
          end
        end
      end
    end
  end
end

# Configure Jekyll to watch .tex files
Jekyll::Hooks.register :site, :after_init do |site|
  # Add .tex extension to Jekyll's include patterns for watching
  site.config['include'] ||= []
  site.config['include'] << '**/*.tex' unless site.config['include'].include?('**/*.tex')
  
  # Force regeneration when .tex files change
  if site.config['watch']
    puts "LaTeX Compiler: Watching .tex files for changes..."
  end
end

# Run **after** Jekyll has read the source tree but **before**
# it renders anything, so new .md files are picked up.
Jekyll::Hooks.register :site, :post_read do |site|
  TexToMd.compile_tex_files(site)
end

# Also run during watch mode when the site resets for regeneration
Jekyll::Hooks.register :site, :after_reset do |site|
  TexToMd.compile_tex_files(site)
end
